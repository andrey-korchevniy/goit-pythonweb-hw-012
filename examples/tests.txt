рактичний приклад PyTest
У попередньому розділі ми розглянули реалізацію модульних тестів для функції get_recipe з використанням бібліотеки unittest. Тепер ми продемонструємо, як ці самі тести можна переписати за допомогою pytest, що дозволить нам скористатися перевагами цього фреймворку для тестування.

Основні зміни при переході на pytest будуть такими:

Використання фікстур замість методів setUpClass і tearDownClass.
Застосування параметризації тестів для зменшення дублювання коду.
Спрощення синтаксису завдяки використанню assert.
Використання вбудованого механізму бібліотеки pytest для перевірки винятків.


Нижче наведемо оновлену версію тестів, яка демонструє ці зміни й показує, як можна написати більш лаконічні тести.

import pytest
from unittest.mock import patch, mock_open

def get_recipe(path, search_id):
    result = None
    with open(path, "r") as f:
        for line in f:
            (id, name, *recipes) = line.strip().split(",")
            if id == search_id:
                result = {"id": id, "name": name, "ingredients": recipes}
    return result

@pytest.fixture
def mock_recipes_data():
    return (
        "60b90c1c13067a15887e1ae1,Herbed Baked Salmon,4 lemons,1 large red onion,2 tablespoons chopped fresh basil\\n"
        "60b90c2413067a15887e1ae2,Lemon Pancakes,2 tablespoons baking powder,1 cup vanilla-flavored almond milk,1 lemon\\n"
        "60b90c2e13067a15887e1ae3,Chicken and Cold Noodles,6 ounces dry Chinese noodles,1 tablespoon sesame oil,3 tablespoons soy sauce"
    )

@pytest.fixture
def mock_file(mock_recipes_data):
    return mock_open(read_data=mock_recipes_data)

@pytest.mark.parametrize(
    "uuid,expected_name,expected_ingredients",
    [
        (
            "60b90c1c13067a15887e1ae1",
            "Herbed Baked Salmon",
            ["4 lemons", "1 large red onion", "2 tablespoons chopped fresh basil"],
        ),
        (
            "60b90c2413067a15887e1ae2",
            "Lemon Pancakes",
            [
                "2 tablespoons baking powder",
                "1 cup vanilla-flavored almond milk",
                "1 lemon",
            ],
        ),
    ],
)
def test_get_existing_recipe(uuid, expected_name, expected_ingredients, mock_file):
    filename = "fake.csv"
    with patch("builtins.open", mock_file):
        result = get_recipe(filename, uuid)
        assert result["id"] == uuid
        assert result["name"] == expected_name
        assert result["ingredients"] == expected_ingredients

def test_get_nonexistent_recipe(mock_file):
    uuid = "nonexistent_id"
    filename = "fake.csv"
    with patch("builtins.open", mock_file):
        result = get_recipe(filename, uuid)
        assert result is None

def test_empty_file():
    empty_mock = mock_open(read_data="")
    uuid = "60b90c1c13067a15887e1ae1"
    filename = "empty.csv"
    with patch("builtins.open", empty_mock):
        result = get_recipe(filename, uuid)
        assert result is None

def test_file_not_found():
    with patch("builtins.open", side_effect=FileNotFoundError):
        with pytest.raises(FileNotFoundError):
            get_recipe("nonexistent_file.csv", "60b90c1c13067a15887e1ae1")



Виконання:

collected 5 items                                                                       

test_get_recipe.py::test_get_existing_recipe[60b90c1c13067a15887e1ae1-Herbed Baked Salmon-expected_ingredients0] PASSED
test_get_recipe.py::test_get_existing_recipe[60b90c2413067a15887e1ae2-Lemon Pancakes-expected_ingredients1] PASSED
test_get_recipe.py::test_get_nonexistent_recipe PASSED
test_get_recipe.py::test_empty_file PASSED
test_get_recipe.py::test_file_not_found PASSED

================================== 5 passed in 0.04s =================================== 



Ми знаємо, що фікстури в pytest — це функції, які створюють дані або об'єкти для тестів. Вони заміняють методи setUp і tearDown з unittest. Фікстура mock_recipes_data створює тестові дані, а mock_file використовує ці дані для створення об'єкта mock_open.

@pytest.fixture
def mock_recipes_data():
    return (
        "60b90c1c13067a15887e1ae1,Herbed Baked Salmon,4 lemons,1 large red onion,2 tablespoons chopped fresh basil\\n"
        "60b90c2413067a15887e1ae2,Lemon Pancakes,2 tablespoons baking powder,1 cup vanilla-flavored almond milk,1 lemon\\n"
        "60b90c2e13067a15887e1ae3,Chicken and Cold Noodles,6 ounces dry Chinese noodles,1 tablespoon sesame oil,3 tablespoons soy sauce"
    )
    
    
@pytest.fixture
def mock_file(mock_recipes_data):
    return mock_open(read_data=mock_recipes_data) 



Параметризований тест

@pytest.mark.parametrize(
    "uuid,expected_name,expected_ingredients",
    [
        (
            "60b90c1c13067a15887e1ae1",
            "Herbed Baked Salmon",
            ["4 lemons", "1 large red onion", "2 tablespoons chopped fresh basil"],
        ),
        (
            "60b90c2413067a15887e1ae2",
            "Lemon Pancakes",
            [
                "2 tablespoons baking powder",
                "1 cup vanilla-flavored almond milk",
                "1 lemon",
            ],
        ),
    ],
)
def test_get_existing_recipe(uuid, expected_name, expected_ingredients, mock_file):
    filename = "fake.csv"
    with patch("builtins.open", mock_file):
        result = get_recipe(filename, uuid)
        assert result["id"] == uuid
        assert result["name"] == expected_name
        assert result["ingredients"] == expected_ingredients



заміняє тести test_get_first_recipe і test_get_second_recipe.

Декоратор @pytest.mark.parametrize дозволяє запустити один і той самий тест із різними наборами вхідних даних, що робить наш код більш компактним. Тести на рецепт, що не існує, та порожній файл майже не змінилися. Ми тільки виконали заміну інструкції self.assertIsNone(result) на assert result is None.

Тест на відсутній файл перевіряє, чи викидається виняток FileNotFoundError, коли файл не знайдено.

    def test_file_not_found(self):
        with patch("builtins.open", side_effect=FileNotFoundError):
            with self.assertRaises(FileNotFoundError):
                get_recipe("nonexistent_file.csv", "60b90c1c13067a15887e1ae1")



Якщо підбити підсумок, то основні відмінності pytest від unittest — це:

Використання фікстур замість методів setUp і tearDown.
Параметризація тестів для зменшення дублювання коду.
Використання assert замість методів self.assert*.
Використання with pytest.raises() для перевірки винятків.
Бібліотека pytest робить код тестів більш читабельним і легшим для розширення, особливо коли потрібно додати нові тестові випадки. Тому в наступному модулі при покритті тестами нашого застосунку ми будемо використовувати саме бібліотеку pytest.